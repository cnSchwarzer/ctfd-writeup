# modernlevel3

## 由于我们观察到e和n都比较大，所以我们知道这个是wiener attack攻击
## 介绍
与低加密指数相同，低解密指数可以加快解密的过程，但是者也带来了安全问题。Wiener表示如果满足：

d<1/3n^1/4
那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害RSA的安全。此时需要满足：

q<p<2q

如果满足上述条件，通过Wiener Attack可以在多项式时间中分解n，思路如下：

回想一下RSA：

N = pq

φ(n)=(p−1)(q−1)=pq−(p+q)+1=N−(p+q)+1
∵ p, q非常大 ， ∴pq≫p+q， ∴φ(n)≈N
∵ed≡1modφ(n)，∴ed−1=kφ(n)，这个式子两边同除dφ(n)可得：

eφ(n)−kd=1dφ(n)
∵φ(n)≈N，∴eN−kd=1dφ(n)，同样dφ(n)是一个很大的数，所以eN略大于kd
为啥要这么写呢，因为e和N是我们是知道的，公钥中给我们的，所以我们计算出eN后，比它略小的kd怎么出来呢，计算eN的连分数展开，依次算出这个分数每一个渐进分数，由于eN略大于kd，wiener证明了，该攻击能精确的覆盖kd（论文刚不动，只知道结论）

我们来举个例子，现在有一个rsa, e = 42667, N = 64741,我们来求。第一步，我们把分数e/N连分数展开，以此求出每一个渐进分数：0，1, 1/2, 2/3 ….用1/2举例子:

假设1/2成立，则把k=1, d=2代入上面的ed−1=kφ(n)中，显然e,d,k都有了，φ(n)就有了，知道φ(n)有啥用呢？我们知道 φ(n) = pq - (p + q) + 1 = N - (p + q) + 1，N = pq作为公钥我们是知道的，所以知道了φ(n) 我们只要算出N- φ(n)+1就是(p + q)的值，好回到初三，现在知道了pq,和p+q的值，我们如何求出p和q的值呢？很简单，利用韦达定理，我们可以轻松构造出方程x2−(p+q)∗x+pq=0,这个方程的两个根就是我们要求的p,q, 至此rsa中所有的参数都被我们求了出来
## 多的不说直接上代码

```python
# -*- coding: utf8 -*-
import gmpy2
import time
# 展开为连分数
def continuedFra(x, y):
    cF = []
    while y:
        cF += [x / y]
        x, y = y, x % y
    return cF
def Simplify(ctnf):
    numerator = 0
    denominator = 1
    for x in ctnf[::-1]:
        numerator, denominator = denominator, x * denominator + numerator
    return (numerator, denominator)
# 连分数化简
def calculateFrac(x, y):
    cF = continuedFra(x, y)
    cF = map(Simplify, (cF[0:i] for i in xrange(1, len(cF))))
    return cF
# 解韦达定理
def solve_pq(a, b, c):
    par = gmpy2.isqrt(b * b - 4 * a * c)
    return (-b + par) / (2 * a), (-b - par) / (2 * a)
def wienerAttack(e, n):
    for (d, k) in calculateFrac(e, n):
        if k == 0: continue
        if (e * d - 1) % k != 0: continue
        phi = (e * d - 1) / k
        p, q = solve_pq(1, n - phi + 1, n)
        if p * q == n:
            return abs(int(p)), abs(int(q))
    print 'not find!'
n = 21669699875387343975765484834175962461348837371447024695458479154615348697330944566714587217852888702291368306637977095490953192701450127798670425959768118384915082017373951315699899009631834471691811815393784748930880954114446745814058132752897827717077886547911476575751254872623927783670252969995075629255541621917767501261249192653546875104532649043219697616464205772025267019328364349763854659490144531087349974469079255236823096415094552037488277752927579909539401311624671444833332618177513356173537573280352724384376372955100031534236816681805396608147647003653628203258681097552049114308367967967184116839561L
e = 20717541468269984768938524534679430706714860712589983300712432366828367981392533792814384884126053081363266457682162675931547901815985830455612301105504518353600255693451085179954519939635263372257973143178677586338992274607959326361412487748088349413448526455377296931144384663805056580662706419414607407821761761574754611275621927387380065975844282519447660467416826579669726178901884060454994606177784839804528666823956703141147239309978420776148158425922031573513062568162012505209805669623841355103885621402814626329355281853436655713194649170570579414480803671531927080535374958180810697826214794117466378050607L
c = 16533785884751040469172364999099686164745589570439405074360847222833985983573497358900266610649566450109439394110505292510945322212755379172575072751594121060428926571041945019281171888405010980195465813258557093942452441383999291175069344362705746525795477179951990578514067469847019356365958286940845135270761409618990092512376336793247884294298291010357034426391480460782374764536384419196629451497734771340279323299586557005624195295353956297940786726059774076810911700488019699073665957911400820686103618871767285602327103291181684430373560980095367368299877364422136623685581717208370407263191592326417409299168L
p, q = wienerAttack(e, n)
print '[+]Found!'
print '  [-]p =',p
print '  [-]q =',q
print '  [-]n =',p*q
d = gmpy2.invert(e,(p-1)*(q-1))
print '  [-]d =', d
print '  [-]m is:' + hex(pow(c,d,n))[2:].decode('hex')
print '[!]All Done!'

```
于是我们得到了flag
## flag{this_attack_uses_the_continued_fraction_method_to_expose_the_private_key_d_when_d_is_small}
